// src/lib/cam.ts
import type { CamRequest, Tooling, Units, EdgeId } from "@/lib/schema";

function nz(v: number | undefined, def: number){ return (v ?? def); }
function s(v: number, d=3){ return Number(v.toFixed(d)); }
function header(units: Units) { return [ units === "mm" ? "G21" : "G20", "G90", "G17" ]; }

function pocketRectGcode(x: number, y: number, w: number, h: number, depth: number, tool: Tooling): string[] {
  const safeZ = nz(tool.safeZ, 5), stepdown = Math.max(0.1, tool.stepdown);
  const pass = Math.max(0.1, tool.stepover * tool.endmillDiameter);
  const feedXY = nz(tool.feedXY, 800), feedZ = nz(tool.feedZ, 300);
  const cmds: string[] = [];
  cmds.push(`(POCKET x=${s(x)} y=${s(y)} w=${s(w)} h=${s(h)} d=${s(depth)})`, `G0 Z${s(safeZ)}`);
  for (let z = -stepdown; z >= -depth - 1e-6; z -= stepdown) {
    const zc = Math.max(z, -depth);
    cmds.push(`G0 X${s(x)} Y${s(y)}`, `G1 Z${s(zc)} F${s(feedZ)}`);
    let row = 0;
    for (let yy = 0; yy <= h; yy += pass) {
      const yrow = Math.min(y + yy, y + h);
      cmds.push(row % 2 === 0
        ? `G1 X${s(x + w)} Y${s(yrow)} F${s(feedXY)}`
        : `G1 X${s(x)}     Y${s(yrow)} F${s(feedXY)}`);
      row++;
    }
    cmds.push(`G0 Z${s(safeZ)}`);
  }
  return cmds;
}

function slotLineGcode(x1: number, y1: number, x2: number, y2: number, depth: number, tool: Tooling): string[] {
  const safeZ = nz(tool.safeZ, 5), stepdown = Math.max(0.1, tool.stepdown);
  const feedXY = nz(tool.feedXY, 800), feedZ = nz(tool.feedZ, 300);
  const cmds: string[] = [];
  cmds.push(`(SLOT x1=${s(x1)} y1=${s(y1)} x2=${s(x2)} y2=${s(y2)} d=${s(depth)})`, `G0 Z${s(safeZ)}`, `G0 X${s(x1)} Y${s(y1)}`);
  for (let z = -stepdown; z >= -depth - 1e-6; z -= stepdown) {
    const zc = Math.max(z, -depth);
    cmds.push(`G1 Z${s(zc)} F${s(feedZ)}`, `G1 X${s(x2)} Y${s(y2)} F${s(feedXY)}`, `G0 Z${s(safeZ)}`, `G0 X${s(x1)} Y${s(y1)}`);
  }
  return cmds;
}

function rabbetRect(edge: EdgeId, hostW: number, hostL: number, width: number) {
  switch(edge){
    case "N": return { x: 0,            y: hostL - width, w: hostW, h: width };
    case "S": return { x: 0,            y: 0,             w: hostW, h: width };
    case "E": return { x: hostW - width,y: 0,             w: width, h: hostL };
    case "W": return { x: 0,            y: 0,             w: width, h: hostL };
  }
}

export function jobsToGcode(req: CamRequest): string {
  const lines: string[] = [];
  lines.push("(Generated by Cutlist CAM)", ...header(req.units));
  for (const job of req.jobs) {
    lines.push("", `(---- ${job.type} : ${job.label ?? job.host.name} ----)`);
    if (job.type === "RABBET") {
      const { width: hostW, length: hostL } = job.host;
      const r = rabbetRect(job.edge, hostW, hostL, job.width)!;
      lines.push(...pocketRectGcode(r.x, r.y, r.w, r.h, job.depth, req.tooling), "M5");
    } else if (job.type === "DADO" || job.type === "GROOVE") {
      const { width: hostW, length: hostL } = job.host;
      const w = job.width, d = job.depth, off = job.offset;
      if (job.type === "GROOVE" && Math.abs(w - req.tooling.endmillDiameter) < 1e-3) {
        if (job.axis === "X") lines.push(...slotLineGcode(0, off, hostW, off, d, req.tooling));
        else lines.push(...slotLineGcode(off, 0, off, hostL, d, req.tooling));
      } else {
        if (job.axis === "X") lines.push(...pocketRectGcode(0, off - w/2, hostW, w, d, req.tooling));
        else lines.push(...pocketRectGcode(off - w/2, 0, w, hostL, d, req.tooling));
      }
      lines.push("M5");
    }
  }
  lines.push("G0 Z" + s(req.tooling.safeZ ?? 5), "M30");
  return lines.join("\n");
}
